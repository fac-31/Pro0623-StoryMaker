import dotenv from 'dotenv';
dotenv.config();

import { StateGraph } from '@langchain/langgraph';
import { ChatOpenAI } from '@langchain/openai';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import OpenAI from 'openai';
import { addLog } from '$lib/server/storyboardLogStore';
import type { Storyboard } from '$lib/models/storyboard.model';
import type { StoryOutline } from '$lib/models/story';
import type { VisualSlide } from '$lib/models/story';
import { storyOutlineSchema } from '$lib/schemas/story.schema.js'; // Generated by ts-to-zod
import type { SlideOutline } from '$lib/models/story';
import { updateStream } from '$lib/streams';

const llm = new ChatOpenAI({
	modelName: 'gpt-4',
	temperature: 0
}).withStructuredOutput(storyOutlineSchema);

const openai = new OpenAI({
	apiKey: process.env.OPENAI_API_KEY
});

// Node Functions
const generateStoryOutline = async (state: Storyboard): Promise<Partial<Storyboard>> => {
	console.log('[LangGraph] generateStoryOutline called with:', state.prompts);
	addLog(`[LangGraph] generateStoryOutline called with: ${state.prompts}`);

	state.status = 'generating-outline';
	updateStream(state._id.toString(), state);

	const prompt = ChatPromptTemplate.fromTemplate(`
Create a detailed storyboard structure for: {concept}

Requirements:
- Create exactly {numSlides} slides
- Include specific character descriptions for visual generation
- Provide clear narration and/or dialogue for each slide
- Describe the visual scene in detail for image generation
- Specify camera angles and visual style
- Ensure story flows logically from slide to slide
- Calculate accurate timestamps for each slide

Target audience: {targetAudience}
Story style: {storyStyle}
Genre: {genre}
`);

	const chain = prompt.pipe(llm);

	type ChainInput = Parameters<typeof chain.invoke>[0];
	const storyOutLine = (await chain.invoke(state.prompts as ChainInput)) as StoryOutline;

	// Initialize visual slides structure
	const slides: VisualSlide[] = storyOutLine.slideOutlines.map((part, index) => ({
		slideNumber: index + 1,
		imageGenerated: false
	}));

	console.log('[LangGraph] generateStoryOutline result:\n', JSON.stringify(storyOutLine, null, 2));
	addLog(`[LangGraph] generateStoryOutline result: ${JSON.stringify(storyOutLine, null, 2)}`);
	return {
		storyOutline: storyOutLine,
		currentSlide: 1,
		visualSlides: slides
	};
};

const generateImagePrompt = (slide: SlideOutline, characterSheet: string): string => {
	const promptParts: string[] = [];

	// Add scene description & Charactersheet
	promptParts.push(`Character Profiles:\n${characterSheet}`);
	promptParts.push(
		'Please follow the character profiles above exactly—do not alter appearance between panels.'
	);
	promptParts.push(`Scene: ${slide.sceneDescription}`);

	// Add character descriptions
	const characterNames: string[] = [];
	slide.characters.forEach((char) => {
		characterNames.push(char.name);
		let charDesc = `${char.name}: ${char.description}, positioned ${char.position}`;
		if (char.emotions.length > 0) {
			charDesc += `, expressing ${char.emotions.join(', ')}`;
		}
		promptParts.push(charDesc);
	});

	// Add visual style and camera
	promptParts.push(`Visual style: ${slide.visualStyle}`);
	promptParts.push(`Camera angle: ${slide.cameraAngle}`);

	const fullPrompt = `Storyboard panel: ${promptParts.join('. ')}. Professional illustration style, clean lines, suitable for storyboard presentation.`;
	return fullPrompt;
};

const generateCharacterSheet = async (state: Storyboard): Promise<Partial<Storyboard>> => {
	addLog(`[LangGraph] Starting character sheet generation.`);

	// 1. Aggregate all character data from the outline
	const characterData: Record<
		string,
		{ name: string; roles: Set<string>; descriptions: Set<string> }
	> = {};
	for (const slide of state.storyOutline.slideOutlines) {
		for (const ch of slide.characters) {
			if (!characterData[ch.name]) {
				characterData[ch.name] = { name: ch.name, roles: new Set(), descriptions: new Set() };
			}
			characterData[ch.name].roles.add(ch.role);
			characterData[ch.name].descriptions.add(ch.description);
		}
	}

	// 2. Define the synthesis model and prompt once
	const synthesizerLlm = new ChatOpenAI({ modelName: 'gpt-4', temperature: 0 });
	const synthesizerPrompt = ChatPromptTemplate.fromTemplate(`
Based on the following details for a character named "{name}", create a single, cohesive, and definitive visual profile.
This profile will be used as a master reference for an image generation model to ensure visual consistency across multiple scenes.
Combine all unique details into one clear paragraph. Focus on visual appearance.

Character Name: {name}
Known Roles: {roles}
Collected Descriptions:
{descriptions}

Synthesized Profile:`);
	const synthesizerChain = synthesizerPrompt.pipe(synthesizerLlm);

	// 3. Synthesize a profile for each character
	const synthesisPromises = Object.values(characterData).map((charInfo) =>
		synthesizerChain.invoke({
			name: charInfo.name,
			roles: Array.from(charInfo.roles).join(', '),
			descriptions: Array.from(charInfo.descriptions)
				.map((d) => `- ${d}`)
				.join('\n')
		})
	);

	const synthesizedResults = await Promise.all(synthesisPromises);
	// 4. Build the final character sheet string
	const finalSheet = synthesizedResults
		.map((result, index) => {
			const charName = Object.values(characterData)[index].name;
			const profile = (result.content as string).trim();
			return `• ${charName}: ${profile}`;
		})
		.join('\n\n'); // Use double newline for better separation

	console.log('[LangGraph] Synthesized characterSheet →\n', finalSheet);
	addLog(`[LangGraph] Synthesized characterSheet:\n${finalSheet}`);
	return { characterSheet: finalSheet };
};

const generateImage = async (state: Storyboard): Promise<Partial<Storyboard>> => {
	console.log('[LangGraph] generateImage called for slide :', state.currentSlide);
	addLog(`[LangGraph] generateImage called for prompt: ${state.currentSlide}`);

	state.status = 'generating-image';
	updateStream(state._id.toString(), state);

	//create prompt for image generation
	const imagePrompt = generateImagePrompt(
		state.storyOutline.slideOutlines[state.currentSlide - 1],
		state.characterSheet
	);

	try {
		const response = await openai.images.generate({
			model: 'dall-e-3',
			prompt: imagePrompt,
			size: '1792x1024', // Landscape format good for storyboards
			quality: 'standard',
			n: 1
		});

		const imageUrl = response.data && response.data[0] && response.data[0].url;

		const visualSlide: VisualSlide = {
			slideNumber: state.currentSlide,
			imageGenerated: true,
			imagePrompt: imagePrompt, //TODO: do we actually want to store the image prompt for DALL-E?
			imageUrl: imageUrl
		};

		const updatedVisualSlides = [...state.visualSlides];
		updatedVisualSlides[state.currentSlide - 1] = visualSlide;

		if (imageUrl) {
			console.log('[LangGraph] generateImage result:', imageUrl);
			addLog(`[LangGraph] generateImage result: ${imageUrl}`);
		} else {
			console.log('[LangGraph] generateImage failed');
			addLog('[LangGraph] generateImage failed');
		}
		return {
			visualSlides: updatedVisualSlides
		};
	} catch (error) {
		addLog(`Image generation failed:', ${error}`);
		return {};
	}
};

const saveSlideAndAdvance = async (state: Storyboard): Promise<Partial<Storyboard>> => {
	console.log('[LangGraph] saveSlideAndAdvance called for slide:', state.currentSlide);
	addLog(`[LangGraph] saveSlideAndAdvance called for slide: ${state.currentSlide}`);

	const currentSlideNum = state.currentSlide;

	// Advance to next slide. mark complete is in the logic of shouldContinue()
	const nextSlide = currentSlideNum + 1;

	console.log('[LangGraph] saveSlideAndAdvance nextSlide:', nextSlide);
	addLog(`[LangGraph] saveSlideAndAdvance nextSlide: ${nextSlide}`);
	return {
		currentSlide: nextSlide
	};
};

const shouldContinue = (state: Storyboard): 'nextSlide' | 'complete' => {
	return state.currentSlide && state.currentSlide <= state.storyOutline.slideOutlines.length
		? 'nextSlide'
		: 'complete';
};

// Build the Graph
export const createStoryboardGraph = () => {
	console.log('[LangGraph] createStoryboardGraph called');
	addLog('[LangGraph] createStoryboardGraph called');
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const workflow = new StateGraph<Storyboard, any, any, string>({
		channels: {
			_id: null,
			status: null,
			prompts: null,
			storyOutline: null,
			currentSlide: null,
			visualSlides: null
		}
	});

	// Add nodes
	workflow.addNode('generateStoryOutline', generateStoryOutline);
	workflow.addNode('generateCharacterSheet', generateCharacterSheet);
	workflow.addNode('generateImage', generateImage);
	workflow.addNode('saveAndAdvance', saveSlideAndAdvance);

	// Define edges using '__start__' and '__end__' as required
	workflow.addEdge('__start__', 'generateStoryOutline');
	workflow.addEdge('generateStoryOutline', 'generateCharacterSheet');
	workflow.addEdge('generateCharacterSheet', 'generateImage');
	workflow.addEdge('generateImage', 'saveAndAdvance');
	workflow.addConditionalEdges('saveAndAdvance', shouldContinue, {
		nextSlide: 'generateImage',
		complete: '__end__'
	});

	return workflow.compile();
};

// Main execution function
export const runStoryboardCreation = async (storyboard: Storyboard): Promise<Storyboard> => {
	console.log('[LangGraph] runStoryboardCreation called with:', storyboard.prompts);
	addLog(`[LangGraph] runStoryboardCreation called with: ${storyboard.prompts}`);
	const app = createStoryboardGraph();

	storyboard.currentSlide = 1;

	const result = await app.invoke(storyboard);
	console.log('[LangGraph] runStoryboardCreation result:', result);
	addLog(`[LangGraph] runStoryboardCreation result: ${JSON.stringify(result)}`);

	result.updatedAt = new Date();
	result.status = 'done';
	return result as Storyboard;
};

// // Interactive Functions for UI Integration
// export const getCurrentSlideDraft = (state: StoryboardState): SlideContent | null => {
// 	return state.currentSlideDraft;
// };

// export const submitRefinementFeedback = (
// 	state: StoryboardState,
// 	feedback: string
// ): Partial<StoryboardState> => {
// 	return { refinementFeedback: feedback };
// };

// export const approveSlideForGeneration = (): Partial<StoryboardState> => {
// 	return { generationReady: true };
// };
