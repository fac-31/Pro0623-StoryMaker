import { StateGraph } from '@langchain/langgraph';
import { ChatOpenAI } from '@langchain/openai';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import OpenAI from 'openai';
import { addLog } from '$lib/server/storyboardLogStore';
import type { UserPrompt } from '$lib/models/UserPrompt';
import type { StoryOutline } from '$lib/models/story';
import type { VisualSlide } from '$lib/models/story';
import { storySchema } from '$lib/schemas/story.schema.js'; // Generated by ts-to-zod
import type { SlideOutline } from '$lib/models/story';

export interface StoryboardState {
	userConcept: UserPrompt;
	storyOutline: StoryOutline;
	currentSlide: number;
	visualSlides: VisualSlide[];
	generationReady: boolean;
}

const llm = new ChatOpenAI({
    modelName: 'gpt-4',
    temperature: 0,
}).withStructuredOutput(storySchema);

const openai = new OpenAI({
	apiKey: process.env.OPENAI_API_KEY
});

// Node Functions
const generateStoryOutline = async (state: StoryboardState): Promise<Partial<StoryboardState>> => {
	console.log('[LangGraph] generateStoryOutline called with:', state.userConcept);
	addLog(`[LangGraph] generateStoryOutline called with: ${state.userConcept}`);
	const prompt = ChatPromptTemplate.fromTemplate(`
Create a detailed storyboard structure for: {userInput}

Requirements:
- Create exactly {numSlides} slides
- Include specific character descriptions for visual generation
- Provide clear narration and/or dialogue for each slide
- Describe the visual scene in detail for image generation
- Specify camera angles and visual style
- Ensure story flows logically from slide to slide
- Calculate accurate timestamps for each slide

Target audience: {targetAudience}
Story style: {storyStyle}
Genre: {genre}
`);

	const chain = prompt.pipe(llm);
	const storyOutLine = await chain.invoke({
	userInput: state.userConcept.userInput,
	numSlides: state.userConcept.numSlides,
	targetAudience: state.userConcept.targetAudience,
	storyStyle: state.userConcept.storyStyle,
	genre: state.userConcept.genre
	}) as StoryOutline;
	

	// Initialize visual slides structure
	const slides: VisualSlide[] = storyOutLine.slides.map((part, index) => ({
		slideNumber: index + 1,
		imageGenerated: false,
	}));

	console.log('[LangGraph] generateStoryOutline result:', { generateStoryOutline, storyOutLine });
	addLog(`[LangGraph] generateStoryOutline result: ${JSON.stringify({ generateStoryOutline, storyOutLine })}`);
	return {
		storyOutline: storyOutLine,
		currentSlide: 1,
		visualSlides: slides,
	};
};

const generateImagePrompt = (slide: SlideOutline): string => {

	const promptParts: string[] = [];
      
      // Add scene description
      promptParts.push(`Scene: ${slide.sceneDescription}`);
      
      // Add character descriptions
      const characterNames: string[] = [];
      slide.characters.forEach(char => {
        characterNames.push(char.name);
        const charDesc = `${char.name}: ${char.description}, positioned ${char.position}`;
        if (char.emotions.length > 0) {
          charDesc + `, expressing ${char.emotions.join(', ')}`;
        }
        promptParts.push(charDesc);
      });
      
      // Add visual style and camera
      promptParts.push(`Visual style: ${slide.visualStyle}`);
      promptParts.push(`Camera angle: ${slide.cameraAngle}`);
      
      const fullPrompt = `Storyboard panel: ${promptParts.join('. ')}. Professional illustration style, clean lines, suitable for storyboard presentation.`;
	  return fullPrompt
}

const generateImage = async (state: StoryboardState): Promise<Partial<StoryboardState>> => {
	console.log('[LangGraph] generateImage called for slide :', state.currentSlide);
	addLog(`[LangGraph] generateImage called for prompt: ${state.currentSlide}`);
	
	//create prompt for image generation
	const imagePrompt = generateImagePrompt(state.storyOutline.slides[state.currentSlide - 1]);

	try {
		const response = await openai.images.generate({
			model: 'dall-e-3',
			prompt: imagePrompt,
			size: '1792x1024', // Landscape format good for storyboards
			quality: 'standard',
			n: 1
		});

		const imageUrl = response.data && response.data[0] && response.data[0].url;

		const visualSlide: VisualSlide = {
			slideNumber: state.currentSlide,
			imageGenerated: true,
			imagePrompt: imagePrompt, //TODO: do we actually want to store the image prompt for DALL-E?
			imageUrl: imageUrl
		};

		const updatedVisualSlides = [...state.visualSlides];
		updatedVisualSlides[state.currentSlide - 1] = visualSlide;

if (imageUrl) {
			console.log('[LangGraph] generateImage result:', imageUrl);
			addLog(`[LangGraph] generateImage result: ${imageUrl}`);
		} else {
			console.log('[LangGraph] generateImage failed');
			addLog('[LangGraph] generateImage failed');
		}
		return {
			visualSlides: updatedVisualSlides,
		};
	} catch (error) {
		addLog(`Image generation failed:', ${error}`);
		return {
			generationReady: false
		};
	}
};

const saveSlideAndAdvance = async (state: StoryboardState): Promise<Partial<StoryboardState>> => {
	console.log('[LangGraph] saveSlideAndAdvance called for slide:', state.currentSlide);
	addLog(`[LangGraph] saveSlideAndAdvance called for slide: ${state.currentSlide}`);

	const currentSlideNum = state.currentSlide;

	
	const slides = [...state.visualSlides];

	// Update the current slide with finalized content
	slides[currentSlideNum - 1] = {
		...slides[currentSlideNum - 1],
		content: state.currentSlideDraft,
		imageGenerated: true
	};

	// Advance to next slide or mark complete
	const nextSlide = currentSlideNum < 6 ? currentSlideNum + 1 : null;

	console.log('[LangGraph] saveSlideAndAdvance nextSlide:', nextSlide);
	addLog(`[LangGraph] saveSlideAndAdvance nextSlide: ${nextSlide}`);
	return {
		visualSlides: slides,
		currentSlide: nextSlide,
		generationReady: false
	};
};


const shouldContinue = (state: StoryboardState): 'nextSlide' | 'complete' => {
	return state.currentSlide && state.currentSlide <= 6 ? 'nextSlide' : 'complete';
};

// Build the Graph
export const createStoryboardGraph = () => {
	console.log('[LangGraph] createStoryboardGraph called');
	addLog('[LangGraph] createStoryboardGraph called');
	// eslint-disable-next-line @typescript-eslint/no-explicit-any


	//First - Input type
	//Second - Output type,
	//Third - 
	const workflow = new StateGraph<StoryboardState, any, any, string>({
		channels: {
			userConcept: null,
			storyOutline: null,
			currentSlide: null,
			visualSlides: null,
			generationReady: null,
			generatedImages: null
		}
	});

	// Add nodes
	workflow.addNode('generateStoryOutline', generateStoryOutline);
	workflow.addNode('generateImage', generateImage);
	workflow.addNode('saveAndAdvance', saveSlideAndAdvance);

	// Define edges using '__start__' and '__end__' as required
	workflow.addEdge('__start__', 'generateStoryOutline');
	workflow.addEdge('generateStoryOutline', 'generateImage');
	workflow.addEdge('generateImage', 'saveAndAdvance');
	workflow.addConditionalEdges('saveAndAdvance', shouldContinue, {
		nextSlide: 'generateImage',
		complete: '__end__'
	});

	return workflow.compile();
};

// Main execution function
export const runStoryboardCreation = async (userConcept: UserPrompt): Promise<StoryboardState> => {
	console.log('[LangGraph] runStoryboardCreation called with:', userConcept);
	addLog(`[LangGraph] runStoryboardCreation called with: ${userConcept}`);
	const app = createStoryboardGraph();

	const initialState: StoryboardState = {
		userConcept,
		storyOutline: { storyMetadata: {
			title: '',
			totalDuration: '',
			genre: '',
			style: '',
			targetAudience: ''
		}, slides: [] },
		currentSlide: 1,
		visualSlides: [],
		generationReady: false,
		generatedImages: []
	};

	const result = await app.invoke(initialState);
	console.log('[LangGraph] runStoryboardCreation result:', result);
	addLog(`[LangGraph] runStoryboardCreation result: ${JSON.stringify(result)}`);
	return result as StoryboardState;
};

// // Interactive Functions for UI Integration
// export const getCurrentSlideDraft = (state: StoryboardState): SlideContent | null => {
// 	return state.currentSlideDraft;
// };

// export const submitRefinementFeedback = (
// 	state: StoryboardState,
// 	feedback: string
// ): Partial<StoryboardState> => {
// 	return { refinementFeedback: feedback };
// };

// export const approveSlideForGeneration = (): Partial<StoryboardState> => {
// 	return { generationReady: true };
// };
