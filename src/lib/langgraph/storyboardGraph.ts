import dotenv from 'dotenv';
dotenv.config();

import { StateGraph } from '@langchain/langgraph';
import { ChatOpenAI } from '@langchain/openai';
import { ChatPromptTemplate } from '@langchain/core/prompts';
import OpenAI from 'openai';
import { addLog } from '$lib/server/storyboardLogStore';
import type { Storyboard } from '$lib/models/storyboard.model';
import type { StoryOutline } from '$lib/models/story';
import type { VisualSlide } from '$lib/models/story';
import { storyOutlineSchema } from '$lib/schemas/story.schema.js'; // Generated by ts-to-zod
import type { SlideOutline } from '$lib/models/story';
import { updateStream } from '$lib/streams';
import { v2 as cloudinary } from 'cloudinary';
import type { RunnableConfig } from '@langchain/core/runnables';

// Configure Cloudinary (usually done in your app initialization)
cloudinary.config({
	cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
	api_key: process.env.CLOUDINARY_API_KEY,
	api_secret: process.env.CLOUDINARY_API_SECRET
});

const llm = new ChatOpenAI({
	modelName: 'gpt-4',
	temperature: 0
}).withStructuredOutput(storyOutlineSchema);

const openai = new OpenAI({
	apiKey: process.env.OPENAI_API_KEY
});

// Node Functions

/**
 * Generates a story outline based on the given storyboard state.
 * @param {Storyboard} state - The current state of the storyboard.
 * @returns {Promise<Partial<Storyboard>>} A promise that resolves to a partial storyboard with the generated outline.
 */
const generateStoryOutline = async (
	state: Storyboard,
	config: RunnableConfig
): Promise<Partial<Storyboard>> => {
	addLog(`[LangGraph] generateStoryOutline called with: ${state.prompts}`);

	state.status = 'generating-outline';
	updateStream(state._id.toString(), state);

	const prompt = ChatPromptTemplate.fromTemplate(`
Create a detailed storyboard structure for: {concept}

Requirements:
- Create exactly {numSlides} slides
- Include specific character descriptions for visual generation
- Provide clear narration and/or dialogue for each slide
- Describe the visual scene in detail for image generation
- Specify camera angles and visual style
- Ensure story flows logically from slide to slide
- Calculate accurate timestamps for each slide

Target audience: {targetAudience}
Story style: {storyStyle}
Genre: {genre}
`);

	const chain = prompt.pipe(llm);

	type ChainInput = Parameters<typeof chain.invoke>[0];
	const storyOutLine = (await chain.invoke(state.prompts as ChainInput, config)) as StoryOutline;

	// Initialize visual slides structure
	const slides: VisualSlide[] = storyOutLine.slideOutlines.map((part, index) => ({
		slideNumber: index + 1,
		imageGenerated: false
	}));

	addLog(`[LangGraph] generateStoryOutline result: ${JSON.stringify(storyOutLine, null, 2)}`);
	return {
		storyOutline: storyOutLine,
		currentSlide: 1,
		visualSlides: slides
	};
};

/**
 * Generates an image prompt based on a slide outline.
 * @param {SlideOutline} slide - The outline of the slide.
 * @returns {string} The generated image prompt.
 */
const generateImagePrompt = (slide: SlideOutline, characterSheet: string): string => {
	const promptParts: string[] = [];
	// Add scene description & Charactersheet
	promptParts.push(`Character Profiles:\n${characterSheet}`);
	promptParts.push(
		'Please follow the character profiles above exactly—do not alter appearance between panels.'
	);
	promptParts.push(`Scene: ${slide.sceneDescription}`);

	// Add character descriptions
	const characterNames: string[] = [];
	slide.characters.forEach((char) => {
		characterNames.push(char.name);
		let charDesc = `${char.name}: ${char.description}, positioned ${char.position}`;
		if (char.emotions.length > 0) {
			charDesc += `, expressing ${char.emotions.join(', ')}`;
		}
		promptParts.push(charDesc);
	});

	// Add visual style and camera
	promptParts.push(`Visual style: ${slide.visualStyle}`);
	promptParts.push(`Camera angle: ${slide.cameraAngle}`);

	const fullPrompt = `Storyboard panel: ${promptParts.join('. ')}. Professional illustration style, clean lines, suitable for storyboard presentation.`;
	return fullPrompt;
};

const generateCharacterSheet = async (
	state: Storyboard,
	config: RunnableConfig
): Promise<Partial<Storyboard>> => {
	addLog(`[LangGraph] Starting character sheet generation.`);

	// 1. Aggregate all character data from the outline
	const characterData: Record<
		string,
		{ name: string; roles: Set<string>; descriptions: Set<string> }
	> = {};
	for (const slide of state.storyOutline.slideOutlines) {
		for (const ch of slide.characters) {
			if (!characterData[ch.name]) {
				characterData[ch.name] = { name: ch.name, roles: new Set(), descriptions: new Set() };
			}
			characterData[ch.name].roles.add(ch.role);
			characterData[ch.name].descriptions.add(ch.description);
		}
	}

	// 2. Define the synthesis model and prompt once
	const synthesizerLlm = new ChatOpenAI({ modelName: 'gpt-4', temperature: 0 });
	const synthesizerPrompt = ChatPromptTemplate.fromTemplate(`
Based on the following details for a character named "{name}", create a single, cohesive, and definitive visual profile.
This profile will be used as a master reference for an image generation model to ensure visual consistency across multiple scenes.
Combine all unique details into one clear paragraph. Focus on visual appearance.

Character Name: {name}
Known Roles: {roles}
Collected Descriptions:
{descriptions}

Synthesized Profile:`);
	const synthesizerChain = synthesizerPrompt.pipe(synthesizerLlm);

	// 3. Synthesize a profile for each character
	const synthesisPromises = Object.values(characterData).map((charInfo) =>
		synthesizerChain.invoke(
			{
				name: charInfo.name,
				roles: Array.from(charInfo.roles).join(', '),
				descriptions: Array.from(charInfo.descriptions)
					.map((d) => `- ${d}`)
					.join('\n')
			},
			config
		)
	);

	const synthesizedResults = await Promise.all(synthesisPromises);
	// 4. Build the final character sheet string
	const finalSheet = synthesizedResults
		.map((result, index) => {
			const charName = Object.values(characterData)[index].name;
			const profile = (result.content as string).trim();
			return `• ${charName}: ${profile}`;
		})
		.join('\n\n'); // Use double newline for better separation

	addLog(`[LangGraph] Synthesized characterSheet:\n${finalSheet}`);
	return { characterSheet: finalSheet };
};
const uploadToCloudinary = async (imageUrl: string, slideNumber: number): Promise<string> => {
	try {
		const result = await cloudinary.uploader.upload(imageUrl, {
			folder: 'storyboard-images',
			public_id: `slide-${slideNumber}-${Date.now()}`,
			resource_type: 'image',
			format: 'webp', // Convert to WebP for better compression
			quality: 'auto:good', // Automatic quality optimization
			fetch_format: 'auto', // Automatically choose best format for client
			transformation: [
				{
					width: 1792,
					height: 1024,
					crop: 'limit', // Maintain aspect ratio while limiting size
					quality: 'auto:good'
				}
			],
			tags: ['storyboard', 'generated', `slide-${slideNumber}`]
		});

		return result.secure_url;
	} catch (error) {
		console.error('Cloudinary upload failed:', error);
		throw error;
	}
};

/**
 * Generates an image for the current slide in the storyboard.
 * @param {Storyboard} state - The current state of the storyboard.
 * @returns {Promise<Partial<Storyboard>>} A promise that resolves to a partial storyboard with the generated image.
 */
const generateImage = async (
	state: Storyboard,
	config: RunnableConfig
): Promise<Partial<Storyboard>> => {
	addLog(`[LangGraph] generateImage called for prompt: ${state.currentSlide}`);
	state.status = 'generating-image';
	updateStream(state._id.toString(), state);

	//create prompt for image generation
	const imagePrompt = generateImagePrompt(
		state.storyOutline.slideOutlines[state.currentSlide - 1],
		state.characterSheet
	);

	try {
		const response = await openai.images.generate(
			{
				model: 'dall-e-3',
				prompt: imagePrompt,
				size: '1792x1024', // Landscape format good for storyboards
				quality: 'standard',
				n: 1
			},
			{ signal: config.signal }
		);

		const dalleImageUrl = response.data && response.data[0] && response.data[0].url;

		if (!dalleImageUrl) {
			console.log('[LangGraph] generateImage failed - no image URL returned');
			addLog('[LangGraph] generateImage failed - no image URL returned');
			return {};
		}

		console.log('[LangGraph] DALL-E image generated:', dalleImageUrl);
		addLog(`[LangGraph] DALL-E image generated: ${dalleImageUrl}`);

		// Update status to indicate uploading to Cloudinary
		state.status = 'uploading-image';
		updateStream(state._id.toString(), state);

		// Upload to Cloudinary for optimization and permanent storage
		let finalImageUrl = dalleImageUrl;
		try {
			console.log('[LangGraph] Uploading to Cloudinary...');
			addLog('[LangGraph] Uploading to Cloudinary...');

			finalImageUrl = await uploadToCloudinary(dalleImageUrl, state.currentSlide);

			console.log('[LangGraph] Cloudinary upload successful:', finalImageUrl);
			addLog(`[LangGraph] Cloudinary upload successful: ${finalImageUrl}`);
		} catch (cloudinaryError) {
			console.warn('[LangGraph] Cloudinary upload failed, using DALL-E URL:', cloudinaryError);
			addLog(`[LangGraph] Cloudinary upload failed, using DALL-E URL: ${cloudinaryError}`);
			// Continue with DALL-E URL if Cloudinary fails
		}

		const visualSlide: VisualSlide = {
			slideNumber: state.currentSlide,
			imageGenerated: true,
			imagePrompt: imagePrompt,
			imageUrl: finalImageUrl
		};

		const updatedVisualSlides = [...state.visualSlides];
		updatedVisualSlides[state.currentSlide - 1] = visualSlide;

		console.log('[LangGraph] generateImage completed successfully');
		addLog('[LangGraph] generateImage completed successfully');

		return {
			visualSlides: updatedVisualSlides
		};
	} catch (error) {
		if ((error as Error).name === 'AbortError') {
			console.log('[LangGraph] Image generation was aborted.');
			addLog('[LangGraph] Image generation was aborted.');
			// Re-throw or handle as appropriate for the graph's state
			throw error;
		}
		console.error('[LangGraph] Image generation failed:', error);
		addLog(`[LangGraph] Image generation failed: ${error}`);
		return {};
	}
};

/**
 * Saves the current slide and advances to the next one.
 * @param {Storyboard} state - The current state of the storyboard.
 * @returns {Promise<Partial<Storyboard>>} A promise that resolves to a partial storyboard with the updated current slide.
 */
const saveSlideAndAdvance = async (state: Storyboard): Promise<Partial<Storyboard>> => {
	console.log('[LangGraph] saveSlideAndAdvance called for slide:', state.currentSlide);
	addLog(`[LangGraph] saveSlideAndAdvance called for slide: ${state.currentSlide}`);

	const currentSlideNum = state.currentSlide;

	// Advance to next slide. mark complete is in the logic of shouldContinue()
	const nextSlide = currentSlideNum + 1;

	console.log('[LangGraph] saveSlideAndAdvance nextSlide:', nextSlide);
	addLog(`[LangGraph] saveSlideAndAdvance nextSlide: ${nextSlide}`);
	return {
		currentSlide: nextSlide
	};
};

/**
 * Determines whether to continue to the next slide or complete the storyboard.
 * @param {Storyboard} state - The current state of the storyboard.
 * @returns {'nextSlide' | 'complete'} The decision to move to the next slide or complete the storyboard.
 */
const shouldContinue = (state: Storyboard): 'nextSlide' | 'complete' => {
	return state.currentSlide && state.currentSlide <= state.storyOutline.slideOutlines.length
		? 'nextSlide'
		: 'complete';
};

/**
 * Creates and compiles the storyboard graph workflow.
 * @returns {StateGraph} The compiled storyboard graph workflow.
 */
export const createStoryboardGraph = () => {
	console.log('[LangGraph] createStoryboardGraph called');
	addLog('[LangGraph] createStoryboardGraph called');
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const workflow = new StateGraph<Storyboard, any, any, string>({
		channels: {
			_id: null,
			status: null,
			prompts: null,
			createdAt: null,
			updatedAt: null,
			storyOutline: null,
			currentSlide: null,
			visualSlides: null,
			characterSheet: null
		}
	});

	// Add nodes
	workflow.addNode('generateStoryOutline', generateStoryOutline);
	workflow.addNode('generateCharacterSheet', generateCharacterSheet);
	workflow.addNode('generateImage', generateImage);
	workflow.addNode('saveAndAdvance', saveSlideAndAdvance);

	// Define edges using '__start__' and '__end__' as required
	workflow.addEdge('__start__', 'generateStoryOutline');
	workflow.addEdge('generateStoryOutline', 'generateCharacterSheet');
	workflow.addEdge('generateCharacterSheet', 'generateImage');
	workflow.addEdge('generateImage', 'saveAndAdvance');
	workflow.addConditionalEdges('saveAndAdvance', shouldContinue, {
		nextSlide: 'generateImage',
		complete: '__end__'
	});

	return workflow.compile();
};

/**
 * Creates and compiles the storyboard graph workflow.
 * @returns {StateGraph} The compiled storyboard graph workflow.
 */
export const createStoryboardEditGraph = () => {
	console.log('[LangGraph] createStoryboardEditGraph called');
	addLog('[LangGraph] createStoryboardEditGraph called');
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const workflow = new StateGraph<Storyboard, any, any, string>({
		channels: {
			_id: null,
			status: null,
			prompts: null,
			createdAt: null,
			updatedAt: null,
			storyOutline: null,
			currentSlide: null,
			visualSlides: null,
			characterSheet: null
		}
	});

	// Add nodes
	workflow.addNode('generateImage', generateImage);

	// Define edges using '__start__' and '__end__' as required
	workflow.addEdge('__start__', 'generateImage');
	workflow.addEdge('generateImage', '__end__');

	return workflow.compile();
};

/**
 * Runs the storyboard creation process.
 * @param {Storyboard} storyboard - The initial storyboard state.
 * @returns {Promise<Storyboard>} A promise that resolves to the completed storyboard.
 */
export const runStoryboardCreation = async (
	storyboard: Storyboard,
	signal: AbortSignal
): Promise<Storyboard> => {
	console.log('[LangGraph] runStoryboardCreation called with:', storyboard.prompts);
	addLog(`[LangGraph] runStoryboardCreation called with: ${storyboard.prompts}`);
	const app = createStoryboardGraph();

	storyboard.currentSlide = 1;

	const result = await app.invoke(storyboard, { signal });
	console.log('[LangGraph] runStoryboardCreation result:', result);
	addLog(`[LangGraph] runStoryboardCreation result: ${JSON.stringify(result)}`);

	result.updatedAt = new Date();
	result.status = 'done';
	return result as Storyboard;
};

export const runStoryboardEdit = async (
	storyboard: Storyboard,
	signal: AbortSignal
): Promise<Storyboard> => {
	console.log('[LangGraph] runStoryboardEdit called with currentSlide:', storyboard.currentSlide);
	console.log(
		'[LangGraph] runStoryboardEdit will generate image for slide outline at index:',
		storyboard.currentSlide - 1
	);
	const app = createStoryboardEditGraph();

	const result = await app.invoke(storyboard, { signal });
	console.log('[LangGraph] runStoryboardEdit result:', result);
	addLog(`[LangGraph] runStoryboardEdit result: ${JSON.stringify(result)}`);

	result.updatedAt = new Date();
	result.status = 'done';
	return result as Storyboard;
};

// // Interactive Functions for UI Integration
// /**
//  * Gets the current slide draft from the storyboard state.
//  * @param {StoryboardState} state - The current state of the storyboard.
//  * @returns {SlideContent | null} The current slide draft or null if not available.
//  */
// export const getCurrentSlideDraft = (state: StoryboardState): SlideContent | null => {
// 	return state.currentSlideDraft;
// };

// /**
//  * Submits refinement feedback for the current slide.
//  * @param {StoryboardState} state - The current state of the storyboard.
//  * @param {string} feedback - The refinement feedback.
//  * @returns {Partial<StoryboardState>} A partial storyboard state with the updated feedback.
//  */
// export const submitRefinementFeedback = (
// 	state: StoryboardState,
// 	feedback: string
// ): Partial<StoryboardState> => {
// 	return { refinementFeedback: feedback };
// };

// /**
//  * Approves the current slide for generation.
//  * @returns {Partial<StoryboardState>} A partial storyboard state indicating generation readiness.
//  */
// export const approveSlideForGeneration = (): Partial<StoryboardState> => {
// 	return { generationReady: true };
// };
